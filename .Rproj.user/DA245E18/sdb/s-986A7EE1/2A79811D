{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Stability of Modeling Cognitive Control\"\noutput:\n  pdf_document: default\n  html_notebook: default\n---\n\n# Experiment 1\n\n##Load in packages\n```{r, message=FALSE, warning=FALSE, include=FALSE}\nlibrary(dplyr)\nlibrary(extrafont)\nlibrary(ggthemes)\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(ggalluvial)\nlibrary(data.table)\n```\n\n##Load in data\n```{r, message=FALSE, warning=FALSE, include=FALSE}\n#Loading in the seperate raw datafiles\ndata.raw<- fread(\"Data/Experiment1.csv\")\n```\n\n##Clean the data\n```{r}\n#Make a dataframe of only the necessary variables because these datafiles are yuuuuge\ndata <- data.raw %>% dplyr::select(Subject, BlockNum, Congruency, \n                                   StimSlideSimon.RT, StimSlideFlanker.RT, StimSlideStroop.RT,\n                                   StimSlideSimon.ACC, StimSlideFlanker.ACC, StimSlideStroop.ACC)\n\n#subjects to include based on Whitehead et al., (2018)\nincludesubs <- c(507,508,513,514,517,518,519,520,521,506,515,523,524,525,526,527,528,529,530,532,\n                 533,534,535,537,539,540,541,542,544,545,546,547,548,549,551,553,555,559,560,561,\n                 562,567,568,569,571,573,576,577,578,579,583,584,585,586,587,588,591,592,593,594,\n                 595,596,597,599,601,602,603,605,606,607,608,609,610,611,613,614,615,616,617,619,\n                 620,621,622,623,624,625,626,629,630,631,633,634,635,637,639,640,641,642,643,645,\n                 647,648,649,650,651,652,654,655,656,657,658,659,660,661,662,663,664,665,666,667,\n                 668,669,670,671,672,673,674,675,676,680,678,679,681,683,685,687,689,690,692,693,\n                 694,696,697,698,699,700,701,702,704,705,706,708,710,711,712,713,715,716,718,719,\n                 720,721,723,724,725,726,728,729,730,732,733,734,736,737,738,739,740,741)\n\n#Filter and clean data\ndf.simon <- data %>% mutate(prevcon = lag(Congruency)) %>% #creat previous congruency\n  mutate(acc = lag(StimSlideSimon.ACC)) %>% #create previous accuracy\n  mutate(RT = (StimSlideSimon.RT)) %>% #create general RT variable\n  filter(Subject %in% includesubs & StimSlideSimon.RT != \"\" &\n  (StimSlideSimon.RT > 200 & StimSlideSimon.RT < 3000) & #liberal filter\n  StimSlideSimon.ACC == 1 & prevcon != 'NA' & acc == 1 & #accuracy\n  BlockNum > 2) #experimental only blocks\n\ndf.flanker <- data %>% mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = lag(StimSlideFlanker.ACC)) %>%\n  mutate(RT = (StimSlideFlanker.RT)) %>%\n  filter(Subject %in% includesubs & StimSlideFlanker.RT != \"\" &\n  (StimSlideFlanker.RT > 200 & StimSlideFlanker.RT < 3000) &\n  StimSlideFlanker.ACC == 1 & prevcon != 'NA' & acc == 1 &\n  BlockNum > 2)\n\ndf.stroop <- data %>% mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = lag(StimSlideStroop.ACC)) %>%\n  mutate(RT = (StimSlideStroop.RT)) %>%\n  filter(Subject %in% includesubs &  StimSlideStroop.RT != \"\" &\n  (StimSlideStroop.RT > 200 & StimSlideStroop.RT < 3000) &\n  StimSlideStroop.ACC == 1 & prevcon != 'NA' & acc == 1 &\n  BlockNum > 2)\n\n```\n\n```{r}\ncomputemodels.exp1 <- function(inputdata){\n  #create some empty matrixes to put in the adjusted R2 values\n  model.0.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.1.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.2.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.3.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  \n  count.i <- 0 #counting variable\n  \n  #loop to go through and compute each model, per subject per block\n  for (i in unique(inputdata$Subject)){\n    count.j <- 0\n    count.i <- count.i+1\n    test <- NULL\n    test <- inputdata %>% filter(Subject == i) #only 1 subject\n    for (j in unique(test$BlockNum)){\n      count.j <- count.j+1\n      test.block <- NULL\n      test.block <- test %>% filter(test$BlockNum == j)\n      model.0 <- lm(RT~1, data = test.block) #null model\n      model.1 <- lm(RT~1+Congruency, data = test.block) #congruency model\n      model.2 <- lm(RT~1+prevcon+Congruency, data = test.block) #add previous congruency\n      model.3 <- lm(RT~1+prevcon*Congruency, data = test.block) #SCE interaction\n  \n      #record the adjusted R2 values\n      model.0.R[count.j,count.i] <- summary(model.0)$adj.r.squared\n      model.1.R[count.j,count.i] <- summary(model.1)$adj.r.squared\n      model.2.R[count.j,count.i] <- summary(model.2)$adj.r.squared\n      model.3.R[count.j,count.i] <- summary(model.3)$adj.r.squared\n    }\n  }\n  \n  #create dummy data frame to compute the group, in long format\n  id.model <- matrix(0, nrow = length(unique(inputdata$Subject)), \n                     ncol = length(unique(inputdata$BlockNum)))\n\n  #decide whether the adjusted R2 value for each person, each block\n  #is higher or lower than others, in order to determine group membership\n  for (i in 1:length(unique(inputdata$Subject))){\n    for (j in 1:length(unique(inputdata$BlockNum))){\n      if((model.0.R[j,i] > model.1.R[j,i] & model.0.R[j,i] > model.2.R[j,i] & \n          model.0.R[j,i] > model.3.R[j,i])){\n        id.model[i,j] = 0\n      }\n      if((model.1.R[j,i] > model.0.R[j,i] & model.1.R[j,i] > model.2.R[j,i] & \n          model.1.R[j,i] > model.3.R[j,i])){\n        id.model[i,j] = 1\n      }\n      if((model.2.R[j,i] > model.1.R[j,i] & model.2.R[j,i] > model.0.R[j,i] & \n          model.2.R[j,i] > model.3.R[j,i])){\n        id.model[i,j] = 2\n      }\n      if((model.3.R[j,i] > model.1.R[j,i] & model.3.R[j,i] > model.2.R[j,i] & \n          model.3.R[j,i] > model.0.R[j,i])){\n        id.model[i,j] = 3\n      }\n    }\n  }\n  \n  #put in formate you can plot\n  id.model.test <- cbind(as.data.frame(rep(1:178,6)), \n                         as.data.frame(rep(1:6,each = 178)),\n                         as.data.frame(c(id.model[,1],\n                          id.model[,2],\n                          id.model[,3],\n                          id.model[,4],\n                          id.model[,5],\n                          id.model[,6]))\n                    )\n  #rename columns\n  colnames(id.model.test) <- c(\"Subject\",\"Block\",\"Group\")\n  \nreturn(id.model.test)\n}\n\n```\n\n## Simon Task \n```{r}\nid.model.test <- as.data.frame(computemodels.exp1(df.simon))\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                    values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"),\n                    labels = c(\"None\",\"Congruency\",\"+ Previous Congruency\", \n                               \"Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Simon - Experiment 1\") +\n  theme_classic() +\n  geom_stratum()\n\nsimon.1 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n## Stroop Task \n```{r}\nid.model.test <- as.data.frame(computemodels.exp1(df.stroop))\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                    values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"),\n                    labels = c(\"None\",\"Congruency\",\"+ Previous Congruency\", \n                               \"Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Stroop - Experiment 1\") +\n  theme_classic() +\n  geom_stratum()\n\nstroop.1 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n## Flanker Task \n```{r}\nid.model.test <- as.data.frame(computemodels.exp1(df.flanker))\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                    values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"),\n                    labels = c(\"None\",\"Congruency\",\"+ Previous Congruency\", \n                               \"Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Flanker - Experiment 1\") +\n  theme_classic() +\n  geom_stratum()\n\nflanker.1 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n# Experiment 2\n\n##Load in data\n```{r, message=FALSE, warning=FALSE, include=FALSE}\n#Loading in the seperate raw datafiles\ndata.raw.simon<- read_csv(\"Data/SimonExp2.csv\")\ndata.raw.stroop<- read_csv(\"Data/StroopExp2.csv\")\ndata.raw.flanker<- read_csv(\"Data/FlankerExp2.csv\")\n```\n\n##Clean the data\n```{r}\n#Make a dataframe of only the necessary variables because these datafiles are yuuuuge\ndata.simon <- data.raw.simon %>% \n  dplyr::select(Subject, BlockNum, Congruency, \n      StimSlideSimon.ACC, StimSlideSimon.RT, TargetRepeat)\ndata.flanker <- data.raw.flanker %>% \n  dplyr::select(Subject, BlockNum, Congruency, \n      StimSlideFlanker.ACC, StimSlideFlanker.RT, TargetRepeat)\ndata.stroop <- data.raw.stroop %>% \n  dplyr::select(Subject, BlockNum, Congruency, \n      StimSlideStroop.ACC, StimSlideStroop.RT, TargetRepeat)\n\n#subjects to exclude\nexcludesubs <- c(115,116,126,140,148,153,160,175,188,189,194,195,203,210,212,220,\n                 229,233,237,239,243,250,253,297,901,913,918,145,217,258,280)\n\n#Filter and clean data\n#same method as experiment 1\ndf.simon <- data.simon %>% \n  mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = lag(StimSlideSimon.ACC)) %>%\n  mutate(RT = (StimSlideSimon.RT)) %>%\n  filter(!Subject %in% excludesubs &\n  (StimSlideSimon.RT > 200 & StimSlideSimon.RT < 3000) &\n  StimSlideSimon.ACC == 1 & acc == 1 &\n  BlockNum > 2)\n\ndf.flanker <- data.flanker %>% \n  mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = lag(StimSlideFlanker.ACC)) %>%\n  mutate(RT = (StimSlideFlanker.RT)) %>%\n  filter(!Subject %in% excludesubs &\n  (StimSlideFlanker.RT > 200 & StimSlideFlanker.RT < 3000) &\n  StimSlideFlanker.ACC == 1 & acc == 1 &\n  BlockNum > 2)\n\ndf.stroop <- data.stroop %>% \n  mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = lag(StimSlideStroop.ACC)) %>%\n  mutate(RT = (StimSlideStroop.RT)) %>%\n  filter(!Subject %in% excludesubs & \n  (StimSlideStroop.RT > 200 & StimSlideStroop.RT < 3000) &\n  StimSlideStroop.ACC == 1 & acc == 1 &\n  BlockNum > 2)\n\n```\n\n```{r}\n\ncomputemodels.exp2 <- function(inputdata){\n  #create some empty matrixes to put in the adjusted R2 values\n  model.0.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.1.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.2.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.3.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.4.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.5.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  \n  count.i <- 0 #counting variable\n  \n  #loop to go through and compute each model, per subject per block\n  for (i in unique(inputdata$Subject)){\n    count.j <- 0\n    count.i <- count.i+1\n    test <- NULL\n    test <- inputdata %>% filter(Subject == i) #only 1 subject\n    for (j in unique(test$BlockNum)){\n      count.j <- count.j+1\n      test.block <- NULL\n      test.block <- test %>% filter(test$BlockNum == j)\n      model.0 <- lm(RT~1, data = test.block) #null model\n      model.1 <- lm(RT~1+Congruency, data = test.block) #congruency model\n      model.2 <- lm(RT~1+prevcon*Congruency, data = test.block) #SCE model\n      model.3 <- lm(RT~1+TargetRepeat*Congruency, data = test.block) #Target Rep SCE\n      model.4 <- lm(RT~1+(prevcon*Congruency)+(TargetRepeat*Congruency), data = test.block) #models 2 & 3\n      model.5 <- lm(RT~1+(prevcon*Congruency):(TargetRepeat*Congruency), data = test.block) #interaction 3-way\n  \n  \n      model.0.R[count.j,count.i] <- summary(model.0)$adj.r.squared\n      model.1.R[count.j,count.i] <- summary(model.1)$adj.r.squared\n      model.2.R[count.j,count.i] <- summary(model.2)$adj.r.squared\n      model.3.R[count.j,count.i] <- summary(model.3)$adj.r.squared\n      model.4.R[count.j,count.i] <- summary(model.4)$adj.r.squared\n      model.5.R[count.j,count.i] <- summary(model.5)$adj.r.squared\n    }\n  }\n  \n  #create dummy data frame to compute the group, in long format\n  id.model <- matrix(0, nrow = length(unique(inputdata$Subject)), \n                     ncol = length(unique(inputdata$BlockNum)))\n\n  #decide whether the adjusted R2 value for each person, each block\n  #is higher or lower than others, in order to determine group membership\n  for (i in 1:length(unique(inputdata$Subject))){\n  for (j in 1:length(unique(inputdata$BlockNum))){\n    if((model.0.R[j,i] > model.1.R[j,i] & model.0.R[j,i] > model.2.R[j,i] &\n        model.0.R[j,i] > model.3.R[j,i] & model.0.R[j,i] > model.4.R[j,i] &\n        model.0.R[j,i] > model.5.R[j,i])){\n      id.model[i,j] = 0\n    }\n    if((model.1.R[j,i] > model.0.R[j,i] & model.1.R[j,i] > model.2.R[j,i] &\n        model.1.R[j,i] > model.3.R[j,i] & model.1.R[j,i] > model.4.R[j,i] &\n        model.1.R[j,i] > model.5.R[j,i])){\n      id.model[i,j] = 1\n    }\n    if((model.2.R[j,i] > model.1.R[j,i] & model.2.R[j,i] > model.0.R[j,i] &\n        model.2.R[j,i] > model.3.R[j,i] & model.2.R[j,i] > model.4.R[j,i] &\n        model.2.R[j,i] > model.5.R[j,i])){\n      id.model[i,j] = 2\n    }\n    if((model.3.R[j,i] > model.1.R[j,i] & model.3.R[j,i] > model.2.R[j,i] &\n        model.3.R[j,i] > model.0.R[j,i] & model.3.R[j,i] > model.4.R[j,i] &\n        model.3.R[j,i] > model.5.R[j,i])){\n      id.model[i,j] = 3\n    }\n    if((model.4.R[j,i] > model.1.R[j,i] & model.4.R[j,i] > model.2.R[j,i] &\n        model.4.R[j,i] > model.3.R[j,i] & model.4.R[j,i] > model.0.R[j,i] &\n        model.4.R[j,i] > model.5.R[j,i])){\n      id.model[i,j] = 4\n    }\n    if((model.5.R[j,i] > model.1.R[j,i] & model.5.R[j,i] > model.2.R[j,i] &\n        model.5.R[j,i] > model.3.R[j,i] & model.5.R[j,i] > model.4.R[j,i] &\n        model.5.R[j,i] > model.0.R[j,i])){\n      id.model[i,j] = 5\n    }\n  }\n}\n  \n  #put in formate you can plot\n  if (length(unique(inputdata$BlockNum))>5){\n  id.model.test <- cbind(as.data.frame(rep(1:length(unique(inputdata$Subject)),6)), \n                         as.data.frame(rep(1:6,each = length(unique(inputdata$Subject)))),\n                         as.data.frame(c(id.model[,1],\n                          id.model[,2],\n                          id.model[,3],\n                          id.model[,4],\n                          id.model[,5],\n                          id.model[,6]))\n                    )\n  }\n  else{\n  id.model.test <- cbind(as.data.frame(rep(1:length(unique(inputdata$Subject)),5)), \n                         as.data.frame(rep(1:5,each = length(unique(inputdata$Subject)))),\n                         as.data.frame(c(id.model[,1],\n                          id.model[,2],\n                          id.model[,3],\n                          id.model[,4],\n                          id.model[,5]))\n                    )\n  }\n  #rename columns\n  colnames(id.model.test) <- c(\"Subject\",\"Block\",\"Group\")\n  \nreturn(id.model.test)\n}\n```\n\n## Simon Task\n```{r}\nid.model.test <- computemodels.exp2(df.simon)\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                   values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\n                              \"#8da0cb\",\"#a6d854\",\"#ffd92f\"),\n                   labels = c(\"None\", \"Congruency\",\"Control SCE\", \n                              \"Priming SCE\", \"Control SCE + Priming SCE\", \"Three-Way Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Simon - Experiment 2\") +\n  theme_classic() +\n  geom_stratum()\n\nsimon.2 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n## Stroop Task\n```{r}\nid.model.test <- computemodels.exp2(df.stroop)\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                   values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\n                              \"#8da0cb\",\"#a6d854\",\"#ffd92f\"),\n                   labels = c(\"None\", \"Congruency\",\"Control SCE\", \n                              \"Priming SCE\", \"Control SCE + Priming SCE\", \"Three-Way Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Stroop - Experiment 2\") +\n  theme_classic() +\n  geom_stratum()\n\nstroop.2 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n## Flanker Task\n```{r}\nid.model.test <- computemodels.exp2(df.flanker)\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                   values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\n                              \"#8da0cb\",\"#a6d854\",\"#ffd92f\"),\n                   labels = c(\"None\", \"Congruency\",\"Control SCE\", \n                              \"Priming SCE\", \"Control SCE + Priming SCE\", \"Three-Way Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Flanker - Experiment 2\") +\n  theme_classic() +\n  geom_stratum()\n\nflanker.2 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n# Experiment 3\n\n##Load in data\n```{r, message=FALSE, warning=FALSE, include=FALSE}\n#Loading in the seperate raw datafiles\ndata.raw.simon<- read_csv(\"Data/SimonExp3.csv\")\ndata.raw.stroop<- read_csv(\"Data/StroopExp3.csv\")\ndata.raw.flanker<- read_csv(\"Data/FlankerExp3.csv\")\n```\n\n##Clean the data\n```{r}\n#Make a dataframe of only the necessary variables because these datafiles are yuuuuge\ndata.simon <- data.raw.simon %>% \n  dplyr::select(Subject, PracExp, BlockNum, Congruency, \n  StimSlideSimon.ACC, StimSlideSimon.RT, Position)\ndata.flanker <- data.raw.flanker %>% \n  dplyr::select(Subject, PracExp, BlockNum, Congruency, \n  StimSlideFlanker.ACC, StimSlideFlanker.RT, Color)\ndata.stroop <- data.raw.stroop %>% \n  dplyr::select(Subject, PracExp, BlockNum, Congruency, \n  StimSlideStroop.ACC, StimSlideStroop.RT, Color)\n\n#subjects to exclude\nincludesubs <- c(105,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,\n                 131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,\n                 155,156,157,158,159,160,161,162,163,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,\n                 180,181,182,183,184,185,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,\n                 205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,228,229,\n                 231,232,233,234,235,236,237,238,240,241,242,243,244,246,247,248,249,250,251,253,254,255,256,257,\n                 259,260,261,262,263,264,265,266,267,268,269,270,271,273,274,275,277,278,279,280,281,282,283,284,\n                 285,286,287,288,289,290,291,293,294,295,296,297,299,301,303,305,306,307,308,309,311,312,313,314,\n                 316,317,318,319,320,321,322,323,324,325,326,327,328,330,331,332,333,334)\n\n#Filter and clean data\n#Same as previous\ndf.simon <- data.simon %>% \n  mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = lag(StimSlideSimon.ACC)) %>%\n  mutate(RT = (StimSlideSimon.RT)) %>%\n  mutate(targetlag = lag(Position)) %>%\n  mutate(TargetRepeat = ifelse(targetlag == Position, 1, 0)) %>%\n  filter(Subject %in% includesubs &\n  (StimSlideSimon.RT > 200 & StimSlideSimon.RT < 3000) &\n  StimSlideSimon.ACC == 1 & acc == 1 &\n  PracExp == \"Exp\")\n\ndf.flanker <- data.flanker %>% \n  mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = lag(StimSlideFlanker.ACC)) %>%\n  mutate(RT = (StimSlideFlanker.RT)) %>%\n  mutate(targetlag = lag(Color)) %>%\n  mutate(TargetRepeat = ifelse(targetlag == Color, 1, 0)) %>%\n  filter(Subject %in% includesubs &\n  (StimSlideFlanker.RT > 200 & StimSlideFlanker.RT < 3000) &\n  StimSlideFlanker.ACC == 1 & acc == 1 &\n  PracExp == \"Exp\")\n\ndf.stroop <- data.stroop %>% \n  mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = lag(StimSlideStroop.ACC)) %>%\n  mutate(RT = (StimSlideStroop.RT)) %>%\n  mutate(targetlag = lag(Color)) %>%\n  mutate(TargetRepeat = ifelse(targetlag == Color, 1, 0)) %>%\n  filter(Subject %in% includesubs & \n  (StimSlideStroop.RT > 200 & StimSlideStroop.RT < 3000) &\n  StimSlideStroop.ACC == 1 & acc == 1 &\n  PracExp == \"Exp\")\n\n#duplicate function\ncomputemodels.exp3 <- computemodels.exp2\n\n```\n\n## Simon Task\n```{r}\nid.model.test <- computemodels.exp3(df.simon)\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                   values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\n                              \"#8da0cb\",\"#a6d854\",\"#ffd92f\"),\n                   labels = c(\"None\", \"Congruency\",\"Control SCE\", \n                              \"Priming SCE\", \"Control SCE + Priming SCE\", \"Three-Way Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Simon - Experiment 3\") +\n  theme_classic() +\n  geom_stratum()\n\nsimon.3 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n## Stroop Task\n```{r}\nid.model.test <- computemodels.exp3(df.stroop)\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                   values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\n                              \"#8da0cb\",\"#a6d854\",\"#ffd92f\"),\n                   labels = c(\"None\", \"Congruency\",\"Control SCE\", \n                              \"Priming SCE\", \"Control SCE + Priming SCE\", \"Three-Way Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Stroop - Experiment 3\") +\n  theme_classic() +\n  geom_stratum()\n\nstroop.3 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n## Flanker Task\n```{r}\nid.model.test <- computemodels.exp3(df.flanker)\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                   values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\n                              \"#8da0cb\",\"#a6d854\",\"#ffd92f\"),\n                   labels = c(\"None\", \"Congruency\",\"Control SCE\", \n                              \"Priming SCE\", \"Control SCE + Priming SCE\", \"Three-Way Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Flanker - Experiment 3\") +\n  theme_classic() +\n  geom_stratum()\n\nflanker.3 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n# Experiment 4\n\n```{r, message=FALSE, warning=FALSE, include=FALSE}\n#Loading in the seperate raw datafiles\ndata.raw<- read_csv(\"Data/Experiment4_FO.csv\")\n\n#Filter and clean data\n#Same as previous\ndf.simon <- data.raw %>% \n  filter(Task3 == \"Simon\") %>%\n  mutate(Congruency = Cong) %>%\n  mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = resp.corr) %>%\n  mutate(prevacc = lag(acc)) %>%\n  mutate(targetlag = lag(CR)) %>%\n  mutate(Subject = participant) %>%\n  mutate(TargetRepeat = ifelse(targetlag == CR, 1, 0)) %>%\n  filter((RT > 200 & RT < 3000) &\n  acc == 1 & prevacc == 1)\n\ndf.flanker <- data.raw %>% \n  filter(Task3 == \"Flanker\") %>%\n  mutate(Congruency = Cong) %>%\n  mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = resp.corr) %>%\n  mutate(prevacc = lag(acc)) %>%\n  mutate(targetlag = lag(CR)) %>%\n  mutate(Subject = participant) %>%\n  mutate(TargetRepeat = ifelse(targetlag == CR, 1, 0)) %>%\n  filter((RT > 200 & RT < 3000) &\n  acc == 1 & prevacc == 1)\n\ndf.stroop <- data.raw %>% \n  filter(Task3 == \"Stroop\") %>%\n  mutate(Congruency = Cong) %>%\n  mutate(prevcon = lag(Congruency)) %>%\n  mutate(acc = resp.corr) %>%\n  mutate(prevacc = lag(acc)) %>%\n  mutate(targetlag = lag(CR)) %>%\n  mutate(Subject = participant) %>%\n  mutate(TargetRepeat = ifelse(targetlag == CR, 1, 0)) %>%\n  filter((RT > 200 & RT < 3000) &\n  acc == 1 & prevacc == 1)\n\n```\n\n```{r}\ncomputemodels.exp4 <- function(inputdata){\n  #create some empty matrixes to put in the adjusted R2 values\n  model.0.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.1.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.2.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.3.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.4.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  model.5.R <- matrix(0, nrow = length(unique(inputdata$BlockNum)), \n                      ncol = length(unique(inputdata$Subject)))\n  \n  count.i <- 0 #counting variable\n  \n  #loop to go through and compute each model, per subject per block\n  for (i in unique(inputdata$Subject)){\n    count.j <- 0\n    count.i <- count.i+1\n    test <- NULL\n    test <- inputdata %>% filter(Subject == i) #only 1 subject\n    for (j in unique(test$BlockNum)){\n      count.j <- count.j+1\n      test.block <- NULL\n      test.block <- test %>% filter(test$BlockNum == j)\n      model.0 <- lm(RT~1, data = test.block) #null model\n      model.1 <- lm(RT~1+Congruency, data = test.block) #congruency model\n      model.2 <- lm(RT~1+prevcon*Congruency, data = test.block) #SCE model\n      model.3 <- lm(RT~1+TargetRepeat*Congruency, data = test.block) #Target Rep SCE\n      model.4 <- lm(RT~1+(prevcon*Congruency)+(TargetRepeat*Congruency), data = test.block) #models 2 & 3\n      model.5 <- lm(RT~1+(prevcon*Congruency):(TargetRepeat*Congruency), data = test.block) #interaction 3-way\n  \n  \n      model.0.R[count.j,count.i] <- summary(model.0)$adj.r.squared\n      model.1.R[count.j,count.i] <- summary(model.1)$adj.r.squared\n      model.2.R[count.j,count.i] <- summary(model.2)$adj.r.squared\n      model.3.R[count.j,count.i] <- summary(model.3)$adj.r.squared\n      model.4.R[count.j,count.i] <- summary(model.4)$adj.r.squared\n      model.5.R[count.j,count.i] <- summary(model.5)$adj.r.squared\n    }\n  }\n  \n  #create dummy data frame to compute the group, in long format\n  id.model <- matrix(0, nrow = length(unique(inputdata$Subject)), \n                     ncol = length(unique(inputdata$BlockNum)))\n\n  #decide whether the adjusted R2 value for each person, each block\n  #is higher or lower than others, in order to determine group membership\n  for (i in 1:length(unique(inputdata$Subject))){\n  for (j in 1:length(unique(inputdata$BlockNum))){\n    if((model.0.R[j,i] > model.1.R[j,i] & model.0.R[j,i] > model.2.R[j,i] &\n        model.0.R[j,i] > model.3.R[j,i] & model.0.R[j,i] > model.4.R[j,i] &\n        model.0.R[j,i] > model.5.R[j,i])){\n      id.model[i,j] = 0\n    }\n    if((model.1.R[j,i] > model.0.R[j,i] & model.1.R[j,i] > model.2.R[j,i] &\n        model.1.R[j,i] > model.3.R[j,i] & model.1.R[j,i] > model.4.R[j,i] &\n        model.1.R[j,i] > model.5.R[j,i])){\n      id.model[i,j] = 1\n    }\n    if((model.2.R[j,i] > model.1.R[j,i] & model.2.R[j,i] > model.0.R[j,i] &\n        model.2.R[j,i] > model.3.R[j,i] & model.2.R[j,i] > model.4.R[j,i] &\n        model.2.R[j,i] > model.5.R[j,i])){\n      id.model[i,j] = 2\n    }\n    if((model.3.R[j,i] > model.1.R[j,i] & model.3.R[j,i] > model.2.R[j,i] &\n        model.3.R[j,i] > model.0.R[j,i] & model.3.R[j,i] > model.4.R[j,i] &\n        model.3.R[j,i] > model.5.R[j,i])){\n      id.model[i,j] = 3\n    }\n    if((model.4.R[j,i] > model.1.R[j,i] & model.4.R[j,i] > model.2.R[j,i] &\n        model.4.R[j,i] > model.3.R[j,i] & model.4.R[j,i] > model.0.R[j,i] &\n        model.4.R[j,i] > model.5.R[j,i])){\n      id.model[i,j] = 4\n    }\n    if((model.5.R[j,i] > model.1.R[j,i] & model.5.R[j,i] > model.2.R[j,i] &\n        model.5.R[j,i] > model.3.R[j,i] & model.5.R[j,i] > model.4.R[j,i] &\n        model.5.R[j,i] > model.0.R[j,i])){\n      id.model[i,j] = 5\n    }\n  }\n}\n  \n  #put in formate you can plot\n  \n  id.model.test <- cbind(as.data.frame(rep(1:length(unique(inputdata$Subject)),3)), \n                         as.data.frame(rep(1:3,each = length(unique(inputdata$Subject)))),\n                         as.data.frame(c(id.model[,1],\n                          id.model[,2],\n                          id.model[,3]))\n                    )\n\n  #rename columns\n  colnames(id.model.test) <- c(\"Subject\",\"Block\",\"Group\")\n  \nreturn(id.model.test)\n}\n```\n\n## Simon Task\n```{r}\nid.model.test <- computemodels.exp4(df.simon)\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                   values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\n                              \"#8da0cb\",\"#a6d854\",\"#ffd92f\"),\n                   labels = c(\"None\", \"Congruency\",\"Control SCE\", \n                              \"Priming SCE\", \"Control SCE + Priming SCE\", \"Three-Way Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Simon - Experiment 4\") +\n  theme_classic() +\n  geom_stratum()\n\nsimon.4 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n## Stroop Task\n```{r}\nid.model.test <- computemodels.exp4(df.stroop)\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                   values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\n                              \"#8da0cb\",\"#a6d854\",\"#ffd92f\"),\n                   labels = c(\"None\", \"Congruency\",\"Control SCE\", \n                              \"Priming SCE\", \"Control SCE + Priming SCE\", \"Three-Way Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Stroop - Experiment 4\") +\n  theme_classic() +\n  geom_stratum()\n\nstroop.4 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n## Flanker Task\n```{r}\nid.model.test <- computemodels.exp4(df.flanker)\n\nggplot(id.model.test, \n       aes(x = Block, stratum = factor(Group), alluvium = Subject,\n          fill =factor(Group), label = factor(Group))) +\n  scale_fill_brewer(type = \"qual\", palette = \"Set2\") +\n  geom_flow(stat = \"flow\",\n            color = \"darkgray\") +\n  scale_fill_manual(name  = \"Model Group\",\n                   values = c(\"#e78ac3\",\"#66c2a5\",\"#fc8d62\",\n                              \"#8da0cb\",\"#a6d854\",\"#ffd92f\"),\n                   labels = c(\"None\", \"Congruency\",\"Control SCE\", \n                              \"Priming SCE\", \"Control SCE + Priming SCE\", \"Three-Way Interaction\")) +\n  ylab(\"Subject\") +\n  ggtitle(\"Flanker - Experiment 4\") +\n  theme_classic() +\n  geom_stratum()\n\nflanker.4 <- id.model.test %>% group_by(Subject) %>% \n  mutate(switch = lag(Group), switchstay = ifelse(switch == Group, 0, 1)) %>% \n  filter(Block != 1) %>%\n  group_by(Block) %>%\n  summarize(switchprop = sum(switchstay)/length(unique(id.model.test$Subject))) %>%\n  summarize(totalswitch = sum(switchprop)/length(unique(id.model.test$Block)))\n```\n\n# Overall Switching Rate for each Experiment\n```{r}\nplot.switch <- as.data.frame(cbind(rep(1:3,each=4),rep(1:4,3),\n                     rbind(simon.1,simon.2,simon.3,simon.4,\n                           stroop.1,stroop.2,stroop.3,stroop.4,\n                           flanker.1,flanker.2,flanker.3,flanker.4)))\n\ncolnames(plot.switch) <- c(\"Task\",\"Experiment\",\"Percent\")\n\n\nggplot(plot.switch, aes(x = factor(Experiment), y = Percent, group = factor(Task), fill = factor(Task)))  + \n    geom_bar(position = \"dodge\", stat = \"identity\", width = (.75))  + \n    coord_cartesian(ylim = c(.30, 1.00)) +\n    scale_x_discrete(name = \"\", labels=c(\"Exp1 - No Feature Rep\", \"Exp2\", \"Exp3\",\"Exp4 - Fixed Order\")) +\n    scale_fill_manual(name=\"Task\", breaks = c(\"1\",\"2\", \"3\"), \n                      labels=c(\"Simon\", \"Stroop\", \"Flanker\"), \n                      values = c(\"1\" = \"#fdae61\", \"2\" = \"#abdda4\", \"3\" = \"#2b83ba\")) +\n    ggtitle(\"Model Switching Between Tasks/Experiments\") +\n    labs(y=\"Percent of Model Switching Between Blocks (%)\")  +\n    theme_classic(base_size = 12) +\n    #theme(legend.position = c(.75, .9)) +\n    NULL\n```\n",
    "created" : 1549907036432.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1426135546",
    "id" : "2A79811D",
    "lastKnownWriteTime" : 1549980861,
    "last_content_update" : 1549980861872,
    "path" : "~/GitHub/Stability-of-Cognitive-Control/stability analysis.Rmd",
    "project_path" : "stability analysis.Rmd",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}